/**
 * Phase 9.7 - Autonomous Learning Cycle Test Suite
 * ÿßÿÆÿ™ÿ®ÿßÿ± ŸÉÿßŸÖŸÑ ŸÑÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿπŸÑŸëŸÖ ÿßŸÑÿ∞ÿßÿ™Ÿä
 * 
 * Tests:
 * 1. Learning Engine - Pattern Analysis & Insight Generation
 * 2. Action Generator - Decision Generation & Signing
 * 3. Feedback Analyzer - Feedback Processing & Model Update
 * 4. Decision Endpoint - POST /decision
 * 5. Feedback Endpoint - POST /feedback
 * 6. Learning Stats - GET /learning/stats
 */

import axios from 'axios';
import crypto from 'crypto';

const BASE_URL = process.env.BASE_URL || 'http://localhost:5000';
const FEDERATION_BASE = `${BASE_URL}/api/federation`;

// Test data
const TEST_NODE_ID = 'side-node-main-test';

// Colors for output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logTest(testName: string) {
  log(`\n${'='.repeat(60)}`, 'cyan');
  log(`TEST: ${testName}`, 'cyan');
  log('='.repeat(60), 'cyan');
}

function logSuccess(message: string) {
  log(`‚úÖ ${message}`, 'green');
}

function logError(message: string) {
  log(`‚ùå ${message}`, 'red');
}

function logInfo(message: string) {
  log(`‚ÑπÔ∏è  ${message}`, 'blue');
}

/**
 * Test 1: Manual Learning Cycle
 */
async function testLearningCycle(): Promise<boolean> {
  logTest('Learning Engine - Pattern Analysis');
  
  try {
    const response = await axios.post(`${FEDERATION_BASE}/learning/run`, {
      lookbackDays: 7,
      targetNodes: [TEST_NODE_ID]
    });
    
    if (response.status !== 200) {
      logError(`Learning cycle failed: ${response.status}`);
      return false;
    }
    
    const { success, insightsGenerated, insights } = response.data;
    
    if (!success) {
      logError('Learning cycle returned success=false');
      return false;
    }
    
    logSuccess(`Learning cycle completed`);
    logInfo(`Insights generated: ${insightsGenerated}`);
    
    if (insights && insights.length > 0) {
      logInfo(`Sample insight: ${JSON.stringify(insights[0], null, 2)}`);
    }
    
    return true;
    
  } catch (error: any) {
    logError(`Learning cycle error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 2: Auto-Generate Decision
 */
async function testAutoGenerateDecision(): Promise<{ decisionId: string } | null> {
  logTest('Action Generator - Auto-Generate Decision');
  
  try {
    const response = await axios.post(`${FEDERATION_BASE}/decision`, {
      nodeId: TEST_NODE_ID,
      autoGenerate: true
    });
    
    if (response.status !== 200) {
      logError(`Decision generation failed: ${response.status}`);
      return null;
    }
    
    const { success, decision, signature, processingTime } = response.data;
    
    if (!success || !decision) {
      logError('Decision generation returned success=false or no decision');
      return null;
    }
    
    logSuccess(`Decision generated: ${decision.decisionId}`);
    logInfo(`Type: ${decision.type}`);
    logInfo(`Category: ${decision.category}`);
    logInfo(`Confidence: ${decision.confidence.toFixed(2)}`);
    logInfo(`Processing time: ${processingTime}ms`);
    logInfo(`Signature: ${signature.substring(0, 20)}...`);
    
    if (decision.payload) {
      logInfo(`Payload: ${JSON.stringify(decision.payload, null, 2)}`);
    }
    
    return { decisionId: decision.decisionId };
    
  } catch (error: any) {
    // If no insights available, that's expected
    if (error.response?.status === 404) {
      logInfo('No insights available for auto-generation (expected if no data)');
      return null;
    }
    
    logError(`Decision generation error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return null;
  }
}

/**
 * Test 3: Submit Feedback
 */
async function testSubmitFeedback(decisionId: string): Promise<boolean> {
  logTest('Feedback Analyzer - Process Feedback');
  
  try {
    const feedbackData = {
      decisionId,
      result: 'success',
      impact: 0.87,
      improvements: [
        {
          metric: 'response_time',
          before: 450,
          after: 320,
          improvementPercent: 28.9
        },
        {
          metric: 'memory_usage',
          before: 85,
          after: 72,
          improvementPercent: 15.3
        }
      ],
      notes: 'Optimization applied successfully. System performance improved.',
      executionTime: 1250
    };
    
    const response = await axios.post(`${FEDERATION_BASE}/feedback`, feedbackData);
    
    if (response.status !== 200) {
      logError(`Feedback submission failed: ${response.status}`);
      return false;
    }
    
    const { success, analysis, processingTime } = response.data;
    
    if (!success || !analysis) {
      logError('Feedback processing returned success=false');
      return false;
    }
    
    logSuccess(`Feedback processed: ${analysis.decisionId}`);
    logInfo(`Feedback score: ${analysis.feedbackScore.toFixed(2)}`);
    logInfo(`Actual impact: ${analysis.actualImpact.toFixed(2)}`);
    logInfo(`Success rate: ${analysis.successRate.toFixed(2)}`);
    logInfo(`Should continue: ${analysis.shouldContinue}`);
    logInfo(`Processing time: ${processingTime}ms`);
    
    if (analysis.recommendations && analysis.recommendations.length > 0) {
      logInfo('Recommendations:');
      analysis.recommendations.forEach((rec: string, i: number) => {
        logInfo(`  ${i + 1}. ${rec}`);
      });
    }
    
    return true;
    
  } catch (error: any) {
    logError(`Feedback submission error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 4: Get Decisions for Node
 */
async function testGetDecisions(): Promise<boolean> {
  logTest('Get Decisions for Node');
  
  try {
    const response = await axios.get(`${FEDERATION_BASE}/decisions/${TEST_NODE_ID}`);
    
    if (response.status !== 200) {
      logError(`Get decisions failed: ${response.status}`);
      return false;
    }
    
    const { success, nodeId, count, decisions } = response.data;
    
    if (!success) {
      logError('Get decisions returned success=false');
      return false;
    }
    
    logSuccess(`Retrieved ${count} decisions for node: ${nodeId}`);
    
    if (decisions && decisions.length > 0) {
      logInfo(`Latest decision: ${decisions[0].decisionId}`);
      logInfo(`Status: ${decisions[0].status}`);
      logInfo(`Confidence: ${decisions[0].confidence.toFixed(2)}`);
      if (decisions[0].feedbackReceived) {
        logInfo(`Feedback score: ${decisions[0].feedbackScore.toFixed(2)}`);
      }
    }
    
    return true;
    
  } catch (error: any) {
    logError(`Get decisions error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 5: Get Learning Stats
 */
async function testGetLearningStats(): Promise<boolean> {
  logTest('Learning System Statistics');
  
  try {
    const response = await axios.get(`${FEDERATION_BASE}/learning/stats`);
    
    if (response.status !== 200) {
      logError(`Get stats failed: ${response.status}`);
      return false;
    }
    
    const { success, stats } = response.data;
    
    if (!success || !stats) {
      logError('Get stats returned success=false');
      return false;
    }
    
    logSuccess('Learning statistics retrieved');
    
    // Learning stats
    if (stats.learning) {
      logInfo('Learning Engine:');
      logInfo(`  Learning cycle: ${stats.learning.learningCycle}`);
      logInfo(`  Total patterns: ${stats.learning.totalPatterns}`);
      logInfo(`  Avg confidence: ${stats.learning.avgConfidence.toFixed(2)}`);
      logInfo(`  Success rate: ${stats.learning.successRate.toFixed(2)}`);
    }
    
    // Feedback stats
    if (stats.feedback) {
      logInfo('Feedback System:');
      logInfo(`  Total decisions: ${stats.feedback.totalDecisions}`);
      logInfo(`  With feedback: ${stats.feedback.decisionsWithFeedback}`);
      logInfo(`  Avg feedback score: ${stats.feedback.avgFeedbackScore.toFixed(2)}`);
      logInfo(`  Avg success rate: ${stats.feedback.avgSuccessRate.toFixed(2)}`);
      
      if (stats.feedback.topPerformingNodes && stats.feedback.topPerformingNodes.length > 0) {
        logInfo('Top performing nodes:');
        stats.feedback.topPerformingNodes.forEach((node: any, i: number) => {
          logInfo(`  ${i + 1}. ${node.nodeId}: ${(node.successRate * 100).toFixed(1)}%`);
        });
      }
    }
    
    // Nodes stats
    if (stats.nodes) {
      logInfo('Active Nodes:');
      logInfo(`  Total: ${stats.nodes.total}`);
      logInfo(`  Healthy (‚â•80%): ${stats.nodes.active}`);
    }
    
    return true;
    
  } catch (error: any) {
    logError(`Get stats error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 6: End-to-End Learning Cycle
 */
async function testEndToEndCycle(): Promise<boolean> {
  logTest('End-to-End Learning Cycle');
  
  logInfo('Step 1: Run learning cycle...');
  const learningSuccess = await testLearningCycle();
  
  if (!learningSuccess) {
    logError('Learning cycle failed');
    return false;
  }
  
  logInfo('\nStep 2: Generate decision...');
  const decisionResult = await testAutoGenerateDecision();
  
  if (!decisionResult) {
    logInfo('No decision generated (no insights available)');
    logInfo('This is expected if insufficient data exists');
    return true; // Not a failure
  }
  
  logInfo('\nStep 3: Submit feedback...');
  const feedbackSuccess = await testSubmitFeedback(decisionResult.decisionId);
  
  if (!feedbackSuccess) {
    logError('Feedback submission failed');
    return false;
  }
  
  logInfo('\nStep 4: Verify decision updated...');
  const decisionsSuccess = await testGetDecisions();
  
  if (!decisionsSuccess) {
    logError('Failed to retrieve decisions');
    return false;
  }
  
  logSuccess('End-to-end learning cycle completed successfully!');
  return true;
}

/**
 * Main test runner
 */
async function runAllTests() {
  log('\n' + '‚ñà'.repeat(70), 'magenta');
  log('     PHASE 9.7 - AUTONOMOUS LEARNING CYCLE TEST SUITE', 'magenta');
  log('     ÿØŸàÿ±ÿ© ÿßŸÑÿ™ÿπŸÑŸëŸÖ ÿßŸÑÿ∞ÿßÿ™Ÿä ŸÑŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑŸÅÿØÿ±ÿßŸÑŸä', 'magenta');
  log('‚ñà'.repeat(70) + '\n', 'magenta');
  
  const results: { name: string; passed: boolean }[] = [];
  
  // Individual tests
  results.push({
    name: 'Learning Cycle',
    passed: await testLearningCycle()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  results.push({
    name: 'Get Learning Stats',
    passed: await testGetLearningStats()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  results.push({
    name: 'Get Decisions',
    passed: await testGetDecisions()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // End-to-end test
  results.push({
    name: 'End-to-End Cycle',
    passed: await testEndToEndCycle()
  });
  
  // Summary
  log('\n' + '‚ïê'.repeat(70), 'cyan');
  log('TEST SUMMARY', 'cyan');
  log('‚ïê'.repeat(70), 'cyan');
  
  const passed = results.filter(r => r.passed).length;
  const total = results.length;
  
  results.forEach(result => {
    if (result.passed) {
      logSuccess(`${result.name}`);
    } else {
      logError(`${result.name}`);
    }
  });
  
  log('\n' + '‚îÄ'.repeat(70), 'cyan');
  log(`Total: ${passed}/${total} tests passed (${((passed/total) * 100).toFixed(1)}%)`, 
    passed === total ? 'green' : 'yellow');
  log('‚îÄ'.repeat(70) + '\n', 'cyan');
  
  if (passed === total) {
    log('üéâ PHASE 9.7 - AUTONOMOUS LEARNING CYCLE COMPLETE! üéâ\n', 'green');
    log('‚úÖ Learning Engine operational', 'green');
    log('‚úÖ Action Generator functional', 'green');
    log('‚úÖ Feedback Analyzer working', 'green');
    log('‚úÖ Decision endpoints responding', 'green');
    log('‚úÖ Learning cycle executing\n', 'green');
    
    log('Next Steps for SIDE Team:', 'yellow');
    log('1. Implement decision_receiver.ts to receive decisions', 'yellow');
    log('2. Implement feedback_dispatcher.ts to send feedback', 'yellow');
    log('3. Test bi-directional learning cycle', 'yellow');
    log('4. Monitor confidence improvements over time\n', 'yellow');
  } else {
    log('‚ö†Ô∏è  Some tests failed. Review errors above.\n', 'yellow');
  }
  
  process.exit(passed === total ? 0 : 1);
}

// Run tests
runAllTests().catch(error => {
  logError(`Test suite failed: ${error.message}`);
  console.error(error);
  process.exit(1);
});
