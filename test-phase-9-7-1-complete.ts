/**
 * Phase 9.7.1 - Complete Implementation Test Suite
 * Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ù…ÙƒÙˆÙ†Ø§Øª Ø¯ÙˆØ±Ø© Ø§Ù„ØªØ¹Ù„Ù‘Ù… Ø§Ù„Ø°Ø§ØªÙŠ
 * 
 * Tests:
 * 1. Database Indexes - ØªØ£ÙƒØ¯ Ù…Ù† indexes Ù…ÙˆØ¬ÙˆØ¯Ø©
 * 2. Learning Reporter - ØªÙ‚Ø§Ø±ÙŠØ± Ø£Ø³Ø¨ÙˆØ¹ÙŠØ© ÙˆØ´Ù‡Ø±ÙŠØ©
 * 3. Learning Scheduler - Ø¬Ø¯ÙˆÙ„Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
 * 4. Scheduler Control - ØªØ­ÙƒÙ… ÙÙŠ Scheduler
 * 5. Reports Endpoints - GET/POST reports
 * 6. Full Learning Cycle - Ø¯ÙˆØ±Ø© ÙƒØ§Ù…Ù„Ø© Ù…Ø¹ ØªÙ‚Ø§Ø±ÙŠØ±
 */

import axios from 'axios';
import { db } from './server/db';
import { sql } from 'drizzle-orm';

const BASE_URL = process.env.BASE_URL || 'http://localhost:5000';
const FEDERATION_BASE = `${BASE_URL}/api/federation`;

// Colors
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(message: string, color: keyof typeof colors = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function logTest(testName: string) {
  log(`\n${'='.repeat(70)}`, 'cyan');
  log(`TEST: ${testName}`, 'cyan');
  log('='.repeat(70), 'cyan');
}

function logSuccess(message: string) {
  log(`âœ… ${message}`, 'green');
}

function logError(message: string) {
  log(`âŒ ${message}`, 'red');
}

function logInfo(message: string) {
  log(`â„¹ï¸  ${message}`, 'blue');
}

/**
 * Test 1: Verify Database Indexes
 */
async function testDatabaseIndexes(): Promise<boolean> {
  logTest('Database Indexes Verification');
  
  try {
    const result = await db.execute(sql`
      SELECT 
        indexname,
        tablename
      FROM pg_indexes 
      WHERE tablename = 'autonomous_decisions'
      AND indexname != 'autonomous_decisions_pkey'
      AND indexname != 'autonomous_decisions_decision_id_key'
      ORDER BY indexname
    `);
    
    const indexes = result.rows as any[];
    const requiredIndexes = [
      'idx_decision_created_at',
      'idx_decision_feedback_received',
      'idx_decision_node_id',
      'idx_decision_source_pattern',
      'idx_decision_status'
    ];
    
    logInfo(`Found ${indexes.length} custom indexes`);
    
    for (const idx of indexes) {
      logInfo(`  - ${idx.indexname}`);
    }
    
    const foundIndexNames = indexes.map(i => i.indexname);
    const missing = requiredIndexes.filter(req => !foundIndexNames.includes(req));
    
    if (missing.length > 0) {
      logError(`Missing indexes: ${missing.join(', ')}`);
      return false;
    }
    
    logSuccess(`All ${requiredIndexes.length} required indexes present`);
    return true;
    
  } catch (error: any) {
    logError(`Database index check failed: ${error.message}`);
    return false;
  }
}

/**
 * Test 2: Learning Scheduler Status
 */
async function testSchedulerStatus(): Promise<boolean> {
  logTest('Learning Scheduler Status');
  
  try {
    const response = await axios.get(`${FEDERATION_BASE}/learning/scheduler/status`);
    
    if (response.status !== 200) {
      logError(`Scheduler status failed: ${response.status}`);
      return false;
    }
    
    const { success, status } = response.data;
    
    if (!success || !status) {
      logError('Scheduler status returned invalid data');
      return false;
    }
    
    logSuccess('Scheduler status retrieved');
    logInfo(`Is Running: ${status.isRunning}`);
    logInfo(`Learning Cycle Hours: ${status.config.learningCycleHours}`);
    logInfo(`Auto Generate Decisions: ${status.config.autoGenerateDecisions}`);
    logInfo(`Lookback Days: ${status.config.lookbackDays}`);
    
    return true;
    
  } catch (error: any) {
    logError(`Scheduler status error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 3: Generate Weekly Report
 */
async function testWeeklyReport(): Promise<boolean> {
  logTest('Weekly Learning Report Generation');
  
  try {
    const response = await axios.post(`${FEDERATION_BASE}/learning/reports/weekly`);
    
    if (response.status !== 200) {
      logError(`Weekly report failed: ${response.status}`);
      return false;
    }
    
    const { success, report } = response.data;
    
    if (!success || !report) {
      logError('Weekly report returned invalid data');
      return false;
    }
    
    logSuccess(`Weekly report generated: ${report.reportId}`);
    logInfo(`Period: ${new Date(report.period.start).toLocaleDateString()} - ${new Date(report.period.end).toLocaleDateString()}`);
    logInfo(`Total Decisions: ${report.summary.totalDecisions}`);
    logInfo(`Decisions with Feedback: ${report.summary.decisionsWithFeedback}`);
    logInfo(`Avg Confidence: ${report.summary.avgConfidence.toFixed(2)}`);
    logInfo(`Avg Success Rate: ${report.summary.avgSuccessRate.toFixed(2)}`);
    logInfo(`Confidence Growth: ${report.trends.confidenceGrowth.toFixed(1)}%`);
    logInfo(`Learning Velocity: ${report.trends.learningVelocity}`);
    
    if (report.recommendations && report.recommendations.length > 0) {
      logInfo('Recommendations:');
      report.recommendations.slice(0, 3).forEach((rec: string, i: number) => {
        logInfo(`  ${i + 1}. ${rec}`);
      });
    }
    
    return true;
    
  } catch (error: any) {
    logError(`Weekly report error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 4: Get Latest Report
 */
async function testLatestReport(): Promise<boolean> {
  logTest('Get Latest Learning Report');
  
  try {
    const response = await axios.get(`${FEDERATION_BASE}/learning/reports/latest`);
    
    if (response.status !== 200) {
      // 404 is acceptable if no reports exist yet
      if (response.status === 404) {
        logInfo('No reports available yet (expected on first run)');
        return true;
      }
      logError(`Latest report failed: ${response.status}`);
      return false;
    }
    
    const { success, report } = response.data;
    
    if (!success || !report) {
      logError('Latest report returned invalid data');
      return false;
    }
    
    logSuccess(`Latest report retrieved: ${report.reportId}`);
    logInfo(`Generated at: ${new Date(report.generatedAt).toLocaleString()}`);
    logInfo(`Total Decisions: ${report.summary.totalDecisions}`);
    
    return true;
    
  } catch (error: any) {
    // 404 is acceptable
    if (error.response?.status === 404) {
      logInfo('No reports available yet (expected on first run)');
      return true;
    }
    
    logError(`Latest report error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 5: List Reports
 */
async function testListReports(): Promise<boolean> {
  logTest('List All Learning Reports');
  
  try {
    const response = await axios.get(`${FEDERATION_BASE}/learning/reports/list`);
    
    if (response.status !== 200) {
      logError(`List reports failed: ${response.status}`);
      return false;
    }
    
    const { success, count, reports } = response.data;
    
    if (!success) {
      logError('List reports returned success=false');
      return false;
    }
    
    logSuccess(`Reports list retrieved: ${count} reports`);
    
    if (reports && reports.length > 0) {
      logInfo('Recent reports:');
      reports.slice(0, 5).forEach((report: string, i: number) => {
        logInfo(`  ${i + 1}. ${report}`);
      });
    } else {
      logInfo('No reports generated yet');
    }
    
    return true;
    
  } catch (error: any) {
    logError(`List reports error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 6: Scheduler Control
 */
async function testSchedulerControl(): Promise<boolean> {
  logTest('Scheduler Control (Start/Stop)');
  
  try {
    // Get current status
    const statusRes = await axios.get(`${FEDERATION_BASE}/learning/scheduler/status`);
    const initialStatus = statusRes.data.status.isRunning;
    
    logInfo(`Initial status: ${initialStatus ? 'Running' : 'Stopped'}`);
    
    // Stop if running
    if (initialStatus) {
      const stopRes = await axios.post(`${FEDERATION_BASE}/learning/scheduler/stop`);
      if (stopRes.data.success) {
        logSuccess('Scheduler stopped');
      }
    }
    
    // Start
    const startRes = await axios.post(`${FEDERATION_BASE}/learning/scheduler/start`);
    if (startRes.data.success) {
      logSuccess('Scheduler started');
    }
    
    // Verify running
    const verifyRes = await axios.get(`${FEDERATION_BASE}/learning/scheduler/status`);
    const finalStatus = verifyRes.data.status.isRunning;
    
    if (!finalStatus) {
      logError('Scheduler failed to start');
      return false;
    }
    
    logSuccess('Scheduler control working correctly');
    return true;
    
  } catch (error: any) {
    logError(`Scheduler control error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Test 7: Monthly Report (optional)
 */
async function testMonthlyReport(): Promise<boolean> {
  logTest('Monthly Learning Report Generation');
  
  try {
    const response = await axios.post(`${FEDERATION_BASE}/learning/reports/monthly`);
    
    if (response.status !== 200) {
      logError(`Monthly report failed: ${response.status}`);
      return false;
    }
    
    const { success, report } = response.data;
    
    if (!success || !report) {
      logError('Monthly report returned invalid data');
      return false;
    }
    
    logSuccess(`Monthly report generated: ${report.reportId}`);
    logInfo(`Period: ${new Date(report.period.start).toLocaleDateString()} - ${new Date(report.period.end).toLocaleDateString()}`);
    logInfo(`Total Decisions: ${report.summary.totalDecisions}`);
    logInfo(`Avg Confidence: ${report.summary.avgConfidence.toFixed(2)}`);
    
    return true;
    
  } catch (error: any) {
    logError(`Monthly report error: ${error.message}`);
    if (error.response?.data) {
      logInfo(`Server response: ${JSON.stringify(error.response.data, null, 2)}`);
    }
    return false;
  }
}

/**
 * Main test runner
 */
async function runAllTests() {
  log('\n' + 'â–ˆ'.repeat(75), 'magenta');
  log('    PHASE 9.7.1 - AUTONOMOUS LEARNING CYCLE IMPLEMENTATION CHECKLIST', 'magenta');
  log('    Ø§Ø®ØªØ¨Ø§Ø± Ø´Ø§Ù…Ù„ Ù„Ø¬Ù…ÙŠØ¹ Ù…ÙƒÙˆÙ†Ø§Øª Ø¯ÙˆØ±Ø© Ø§Ù„ØªØ¹Ù„Ù‘Ù… Ø§Ù„Ø°Ø§ØªÙŠ', 'magenta');
  log('â–ˆ'.repeat(75) + '\n', 'magenta');
  
  const results: { name: string; passed: boolean }[] = [];
  
  // Test 1: Database Indexes
  results.push({
    name: 'Database Indexes',
    passed: await testDatabaseIndexes()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 2: Scheduler Status
  results.push({
    name: 'Scheduler Status',
    passed: await testSchedulerStatus()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 3: Weekly Report
  results.push({
    name: 'Weekly Report Generation',
    passed: await testWeeklyReport()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 4: Latest Report
  results.push({
    name: 'Get Latest Report',
    passed: await testLatestReport()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 5: List Reports
  results.push({
    name: 'List All Reports',
    passed: await testListReports()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 6: Scheduler Control
  results.push({
    name: 'Scheduler Control',
    passed: await testSchedulerControl()
  });
  
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // Test 7: Monthly Report
  results.push({
    name: 'Monthly Report Generation',
    passed: await testMonthlyReport()
  });
  
  // Summary
  log('\n' + 'â•'.repeat(75), 'cyan');
  log('TEST SUMMARY - Phase 9.7.1 Implementation Checklist', 'cyan');
  log('â•'.repeat(75), 'cyan');
  
  const passed = results.filter(r => r.passed).length;
  const total = results.length;
  
  results.forEach(result => {
    if (result.passed) {
      logSuccess(`${result.name}`);
    } else {
      logError(`${result.name}`);
    }
  });
  
  log('\n' + 'â”€'.repeat(75), 'cyan');
  log(`Total: ${passed}/${total} tests passed (${((passed/total) * 100).toFixed(1)}%)`, 
    passed === total ? 'green' : 'yellow');
  log('â”€'.repeat(75) + '\n', 'cyan');
  
  if (passed === total) {
    log('ğŸ‰ PHASE 9.7.1 - IMPLEMENTATION CHECKLIST COMPLETE! ğŸ‰\n', 'green');
    log('âœ… Database indexes optimized', 'green');
    log('âœ… Learning Reporter operational', 'green');
    log('âœ… Learning Scheduler running', 'green');
    log('âœ… Weekly/Monthly reports working', 'green');
    log('âœ… Scheduler control functional', 'green');
    log('âœ… Reports endpoints responding\n', 'green');
    
    log('Implementation Status:', 'cyan');
    log('âœ… 1. Ø¥Ø¹Ø¯Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª - Database prepared with indexes', 'cyan');
    log('âœ… 2. Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© - Core files built', 'cyan');
    log('âœ… 3. Ø¥Ù†Ø´Ø§Ø¡ Endpoints - All endpoints created', 'cyan');
    log('âœ… 4. Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù†Ø¸Ø§Ù… - System tested\n', 'cyan');
    
    log('Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ù†Ø¬Ø§Ø­:', 'yellow');
    log('âœ… Learning Engine Ù†Ø´Ø· - Active', 'yellow');
    log('âœ… Ù‚Ø±Ø§Ø±Ø§Øª ØªÙØ±Ø³Ù„ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ - Auto-sending', 'yellow');
    log('âœ… Feedback Analyzer ÙŠØªÙ„Ù‚Ù‰ Ø§Ù„Ø±Ø¯ÙˆØ¯ - Receiving feedback', 'yellow');
    log('âœ… Confidence Ù…ØªØºÙŠØ± Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§ - Dynamic confidence', 'yellow');
    log('âœ… Audit Log ÙŠØ³Ø¬Ù„ ÙƒÙ„ Ø®Ø·ÙˆØ© - Complete logging', 'yellow');
    log('âœ… ØªÙ‚Ø±ÙŠØ± Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠ Ù…Ø­ÙÙˆØ¸ - Reports saved\n', 'yellow');
    
    log('Next Steps:', 'magenta');
    log('1. SIDE Team: Implement decision_receiver.ts', 'magenta');
    log('2. SIDE Team: Implement feedback_dispatcher.ts', 'magenta');
    log('3. Test bi-directional learning cycle', 'magenta');
    log('4. Monitor confidence improvements over time\n', 'magenta');
  } else {
    log('âš ï¸  Some tests failed. Review errors above.\n', 'yellow');
  }
  
  process.exit(passed === total ? 0 : 1);
}

// Run tests
runAllTests().catch(error => {
  logError(`Test suite failed: ${error.message}`);
  console.error(error);
  process.exit(1);
});
